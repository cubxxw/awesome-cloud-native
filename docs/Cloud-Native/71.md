+ [author](http://nsddd.top)

# ç¬¬71èŠ‚ OpenIM Gitlink RFC

<div><a href = '70.md' style='float:left'>â¬†ï¸ä¸Šä¸€èŠ‚ğŸ”—  </a><a href = '72.md' style='float: right'>  â¬‡ï¸ä¸‹ä¸€èŠ‚ğŸ”—</a></div>
<br>

> â¤ï¸ğŸ’•ğŸ’•è®°å½•[sealos](https://github.com/cubxxw/sealos)å¼€æºé¡¹ç›®çš„å­¦ä¹ è¿‡ç¨‹ã€‚[k8s,dockerå’Œäº‘åŸç”Ÿçš„å­¦ä¹ ](https://github.com/cubxxw/sealos)ã€‚Myblog:[http://nsddd.top](http://nsddd.top/)

---
[TOC]

## è®¡åˆ’

ä¸ºä»€ä¹ˆéœ€è¦ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å“ªäº›å‰ç½®çŸ¥è¯†ï¼Ÿ

go flutter

+ https://github.com/go-flutter-desktop/go-flutter

ä¸­ç­‰éš¾åº¦çš„æ°´å¹³

è‡ªå·±å®šä¹‰å‡½æ•°ï¼Œè¢«è°ƒ

æ–¹æ¡ˆå°±æ˜¯å¦‚æ­¤~

core è·‘ app

wsam å®ç°äº†ï¼ˆæ–¹æ¡ˆä¸€ï¼‰ï¼Œä½†æ˜¯å°ç¨‹åºæ²¡æœ‰å­˜å‚¨

æ¯ä¸€ä¸ª skd core æ”¾åœ¨æœåŠ¡ç«¯

ä¸€ä¸ª ç”¨æˆ· ï¼ˆæ¯ä¸€ä¸ªï¼‰åœ¨æœåŠ¡ç«¯èµ·ä¸€ä¸ª sdk

ç¬¬äºŒä¸ª æ˜¯ `jssdk server`

js ç”¨ä¸èµ·æ¥



**å°è±¡ï¼š**

jssdk s æœåŠ¡ç«¯

æ¯ä¸€æ¬¡ç™»å½•è¯·æ±‚ new ä¸€ä¸ª 

new å‡ºæ¥åæœ‰ä¸€å¯¹åå°„è°ƒç”¨

æ¯ä¸€æ¬¡è°ƒç”¨ ws æœåŠ¡ç«¯ + core

æ‰¾åˆ° core æ‰¾åˆ°åå°„å‡½æ•°ï¼Œæ‰¾åˆ°å‡½æ•°åå›è°ƒ



login + è·å–ç”¨æˆ·ä¿¡æ¯ ä¸¤ä¸ªæ¨¡å—ã€‚

js ç™»å½• ã€‚

æœåŠ¡ç«¯æ”¶åˆ°ç™»å½•ã€‚

æ¯ä¸€ä¸ªè¯·æ±‚ä¸€ä¸ª core 

ä¹‹å‰æ˜¯ 1+1 ç›´æ¥å®ç°ï¼Œåé¢æ˜¯ 1+1 å°è£…ä¸ºå‡½æ•°ï¼Œç„¶åé€šè¿‡å‡½æ•°æ¥å†³å®šé€»è¾‘

**ç™»å½•å’Œé€€å‡ºç™»å½•é—®é¢˜**





## å¼€æº

C# 

+ https://github.com/OpenIMSDK/Open-IM-SDK-Unity

å®‰å“æ¥è¯´ï¼Œç›´æ¥é€šè¿‡ Unity æ¥æå®š

å®‰å“çš„å·¥ä½œï¼Œunit



## C++

```
go -> c
C++ -> C
```

å‡½æ•°ï¼š

```
func (ws *WServer) msgParse(conn *UserConn, jsonMsg []byte)
```

æ–‡å‹–:

```go
func (wsRouter *WsFuncRouter) GetSelfUserInfo(input string, operationID string) {
   userWorker := open_im_sdk.GetUserWorker(wsRouter.uId)
   if !wsRouter.checkResourceLoadingAndKeysIn(userWorker, input, operationID, runFuncName(), nil) {
      return
   }
   userWorker.User().GetSelfUserInfo(&BaseSuccessFailed{runFuncName(), operationID, wsRouter.uId}, operationID)
}
```

ï¼ˆ1ï¼‰çœ‹ä¸‹jssdk 2ä¸ªå‡½æ•°ï¼Œæ¯”å¦‚ç™»å½•å’Œè·å–ç”¨æˆ·ä¿¡æ¯ï¼Œä»jsåˆ°jssdk serveræ•´ä¸ªæµç¨‹ï¼›

ï¼ˆ2ï¼‰wsæ¡†æ¶ï¼Œæ¢æˆæ–°ç‰ˆæœ¬ï¼ˆæœåŠ¡ç«¯errcodeç‰ˆæœ¬ï¼‰ï¼Œå…·ä½“é—®ä¸‹gordon

ï¼ˆ3ï¼‰é‡ç‚¹è§£å†³å‡ ä¸ªé—®é¢˜ï¼š1.ç™»å½•å’Œé€€å‡ºç™»å½•çš„é—®é¢˜ï¼›



## WobSockets å­¦ä¹ 

1. **å¯¼å…¥åŒ…** ä½ å¯¼å…¥äº†å„ç§åŒ…ï¼Œå…¶ä¸­æœ‰ä¸€äº›å…³äº OpenIM SDK çš„åŒ…ã€websocketã€æ—¥å¿—å’ŒHTTPç›¸å…³çš„åŒ…ã€‚

2. **ä¸»å‡½æ•°** åœ¨ `main()` å‡½æ•°ä¸­ï¼Œä½ çš„ä»£ç é¦–å…ˆå¯åŠ¨äº†ä¸€ä¸ª HTTP æœåŠ¡ï¼Œä¸»è¦ç”¨äºæ”¯æŒ `pprof` ï¼ˆä¸€ä¸ª Go è¯­è¨€å†…å»ºçš„æ€§èƒ½åˆ†æå·¥å…·ï¼‰ã€‚

3. **å‘½ä»¤è¡Œå‚æ•°è§£æ** ä½¿ç”¨ `flag` åŒ…ï¼Œä½ è§£æäº†ä»¥ä¸‹å‘½ä»¤è¡Œå‚æ•°ï¼š

   + `openIM_api_address`ï¼šOpenIM çš„ API æœåŠ¡å™¨åœ°å€ã€‚
   + `openIM_ws_address`ï¼šOpenIM çš„ websocket æœåŠ¡å™¨åœ°å€ã€‚
   + `sdk_ws_port`ï¼šSDK websocket çš„ç›‘å¬ç«¯å£ã€‚
   + `openIM_log_level`ï¼šOpenIM çš„æ—¥å¿—è¾“å‡ºçº§åˆ«ã€‚
   + `openIMDbDir`ï¼šOpenIM çš„æ•°æ®åº“ç›®å½•ã€‚

   è¿™äº›å‚æ•°å…è®¸ä½ åœ¨å¯åŠ¨åº”ç”¨ç¨‹åºæ—¶è¿›è¡Œè‡ªå®šä¹‰é…ç½®ã€‚

4. **æ—¥å¿—åˆå§‹åŒ–** ä½¿ç”¨ `log.NewPrivateLog` åˆå§‹åŒ–äº†æ—¥å¿—ç³»ç»Ÿï¼Œå…¶ä¸­å‚æ•° `constant.LogFileName` æ˜¯æ—¥å¿—æ–‡ä»¶åï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯æ—¥å¿—çš„è¾“å‡ºçº§åˆ«ã€‚

5. **åˆ¤æ–­æ“ä½œç³»ç»Ÿç±»å‹** ä½¿ç”¨ `runtime.GOOS` åˆ¤æ–­æ“ä½œç³»ç»Ÿç±»å‹ã€‚æ ¹æ®ç³»ç»Ÿç±»å‹ï¼Œä»£ç é€‰æ‹©æ€§åœ°è°ƒç”¨ `ws_local_server.InitServer`ã€‚ä½†åœ¨æ­¤ä»£ç ä¸­ï¼Œä¸è®ºç³»ç»Ÿç±»å‹å¦‚ä½•ï¼Œéƒ½æ‰§è¡Œäº†ç›¸åŒçš„é€»è¾‘ã€‚

   1. å¦‚æœæ˜¯ Windows:

   > 1. **å‡½æ•°å®šä¹‰**
   >
   >    `InitServer` å‡½æ•°æ¥å—ä¸€ä¸ªæŒ‡å‘ `sdk_struct.IMConfig` çš„æŒ‡é’ˆå‚æ•°ï¼Œåä¸º `config`ã€‚è¿™ä¸ªç»“æ„ä½“å¯èƒ½åŒ…å«äº† OpenIM SDK çš„åˆå§‹åŒ–é…ç½®ä¿¡æ¯ã€‚
   >
   > 2. **åºåˆ—åŒ–é…ç½®**
   >
   >    ä½¿ç”¨ `json.Marshal` å°† `config` ç»“æ„ä½“åºåˆ—åŒ–æˆ JSON æ ¼å¼ã€‚è¿™æ ·å¯ä»¥æ–¹ä¾¿åœ°å°†é…ç½®ä¿¡æ¯è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œç”¨äºæ—¥å¿—è¾“å‡ºæˆ–å…¶ä»–ç›®çš„ã€‚
   >
   >    ```bash
   >    data, _ := json.Marshal(config)
   >    ConfigSvr = string(data)
   >    ```
   >
   >    æ³¨æ„ï¼šåœ¨è¿™é‡Œï¼Œé”™è¯¯è¢«å¿½ç•¥äº†ï¼ˆç”¨ `_` è¡¨ç¤ºï¼‰ã€‚åœ¨å®é™…çš„ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œé”™è¯¯å¤„ç†æ˜¯å¾ˆé‡è¦çš„ï¼Œåº”è¯¥æ£€æŸ¥ `json.Marshal` æ˜¯å¦è¿”å›äº†ä¸€ä¸ªé”™è¯¯ï¼Œå¹¶ç›¸åº”åœ°å¤„ç†ã€‚
   >
   > 3. **åˆå§‹åŒ–ç”¨æˆ·è·¯ç”±æ˜ å°„**
   >
   >    ```bash
   >    UserRouteMap = make(map[string]RefRouter, 0)
   >    ```
   >
   >    åˆå§‹åŒ–äº†ä¸€ä¸ªåä¸º `UserRouteMap` çš„æ˜ å°„ï¼ˆmapï¼‰ã€‚è¿™ä¸ªæ˜ å°„å¯èƒ½æ˜¯ç”¨æ¥è®°å½•ç”¨æˆ·çš„è·¯ç”±ä¿¡æ¯ã€‚å…¶ä¸­ï¼Œé”®ï¼ˆkeyï¼‰æ˜¯å­—ç¬¦ä¸²ç±»å‹ï¼ˆå¯èƒ½æ˜¯ç”¨æˆ·çš„ ID æˆ–ç”¨æˆ·åï¼‰ï¼Œå€¼ï¼ˆvalueï¼‰æ˜¯ `RefRouter` ç±»å‹ï¼ˆè¯¥ç±»å‹åœ¨è¿™æ®µä»£ç ä¸­æ²¡æœ‰ç»™å‡ºå®šä¹‰ï¼Œä½†å®ƒå¯èƒ½æ˜¯ä¸€ä¸ªå¼•ç”¨åˆ°è·¯ç”±æˆ–ä¼šè¯çš„ç»“æ„æˆ–æ¥å£ï¼‰ã€‚
   >
   > 4. **åˆå§‹åŒ– OpenIM SDK**
   >
   >    ```bash
   >    open_im_sdk.InitOnce(config)
   >    ```
   >
   >    è°ƒç”¨ `open_im_sdk.InitOnce` å‡½æ•°æ¥åˆå§‹åŒ– OpenIM SDKï¼Œå¹¶ä¼ å…¥å‰é¢æåˆ°çš„ `config` ä½œä¸ºå‚æ•°ã€‚
   >
   > 5. **æ—¥å¿—è¾“å‡º**
   >
   >    ```go
   >    log.Info("", "InitServer ", ConfigSvr)
   >    ```
   >
   >    ä½¿ç”¨æ—¥å¿—åº“è¾“å‡ºä¸€æ¡ä¿¡æ¯ï¼Œè¡¨ç¤ºæœåŠ¡å™¨å·²åˆå§‹åŒ–ï¼Œå¹¶é™„å¸¦äº†åºåˆ—åŒ–åçš„é…ç½®ä¿¡æ¯ `ConfigSvr`ã€‚

6. **Websocket æœåŠ¡å™¨åˆå§‹åŒ–å’Œå¯åŠ¨** è°ƒç”¨äº† `ws_local_server.WS.OnInit` å’Œ `ws_local_server.WS.Run` æ¥åˆå§‹åŒ–å¹¶è¿è¡ŒwebsocketæœåŠ¡å™¨ã€‚

å…³äºä½ çš„é—®é¢˜ï¼š

**1. ç™»å½•å’Œé€€å‡ºç™»å½•çš„é—®é¢˜** ä»£ç ä¸­å¹¶æ²¡æœ‰æ¶‰åŠå…·ä½“çš„ç™»å½•å’Œé€€å‡ºç™»å½•çš„é€»è¾‘ã€‚ä½†ä¸€èˆ¬æ¥è¯´ï¼Œä½¿ç”¨WebSocketsè¿›è¡Œç™»å½•çš„æµç¨‹å¤§è‡´æ˜¯ï¼š

+ å®¢æˆ·ç«¯å‘æœåŠ¡å™¨å‘é€ä¸€ä¸ªåŒ…å«ç™»å½•ä¿¡æ¯ï¼ˆå¦‚ç”¨æˆ·åå’Œå¯†ç æˆ–tokenï¼‰çš„websocketæ¶ˆæ¯ã€‚
+ æœåŠ¡å™¨éªŒè¯è¿™äº›ä¿¡æ¯ï¼Œå¹¶å›å¤ä¸€ä¸ªç¡®è®¤æ¶ˆæ¯ï¼Œå‘Šè¯‰å®¢æˆ·ç«¯æ˜¯å¦æˆåŠŸç™»å½•ã€‚

è½¬æ¢ä¸ºç½‘ç»œè°ƒç”¨å¹¶ä½¿ç”¨ `WebSockets` ï¼Œä½ éœ€è¦ç¡®ä¿å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´çš„æ¶ˆæ¯æ ¼å¼å’Œé€»è¾‘éƒ½æ˜ç¡®å¹¶ä¸”ä¸€è‡´ã€‚å¯¹äºç™»å½•å’Œé€€å‡ºç™»å½•ï¼Œä½ å¯èƒ½éœ€è¦å®šä¹‰ä¸åŒçš„æ¶ˆæ¯ç±»å‹ï¼Œå¹¶åœ¨æœåŠ¡å™¨ç«¯è¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚



**Run ä»£ç ï¼š**

```go
func (ws *WServer) Run() {
	go ws.getMsgAndSend()
	go func() {
		http.ListenAndServe("0.0.0.0:45000", nil)
	}()
	http.HandleFunc("/", ws.wsHandler)         //Get request from client to handle by wsHandler
	err := http.ListenAndServe(ws.wsAddr, nil) //Start listening
	if err != nil {
		log.Info("", "Ws listening err", "", "err", err.Error())
	}
}
```

1. **å¼€å¯åç¨‹å¤„ç†æ¶ˆæ¯å‘é€**:

   ```go
   go ws.getMsgAndSend()
   ```

   è¿™é‡Œå¼€å¯äº†ä¸€ä¸ªæ–°çš„åç¨‹ï¼ˆgoroutineï¼‰æ¥è¿è¡Œ `ws.getMsgAndSend()` æ–¹æ³•ã€‚åœ¨ Go è¯­è¨€ä¸­ï¼Œä½¿ç”¨ `go` å…³é”®å­—å¯ä»¥å¼‚æ­¥è¿è¡Œä¸€ä¸ªå‡½æ•°ï¼Œä½¿å…¶åœ¨å•ç‹¬çš„åç¨‹ä¸­æ‰§è¡Œã€‚è¿™æ„å‘³ç€ `getMsgAndSend` æ–¹æ³•æ˜¯å¹¶è¡Œæ‰§è¡Œçš„ï¼Œå¯èƒ½ç”¨äºæŒç»­åœ°ä»æŸä¸ªé€šé“æˆ–é˜Ÿåˆ—ä¸­è·å–æ¶ˆæ¯å¹¶å‘é€å®ƒä»¬ã€‚

   

2. **å¼€å¯å¦ä¸€ä¸ª HTTP æœåŠ¡å™¨ç›‘å¬ç‰¹å®šç«¯å£**:

   ```go
   go func() {
       http.ListenAndServe("0.0.0.0:45000", nil)
   }()
   ```

   è¿™æ®µä»£ç åœ¨ä¸€ä¸ªæ–°çš„åç¨‹ä¸­å¯åŠ¨äº†ä¸€ä¸ª HTTP æœåŠ¡å™¨ï¼Œç›‘å¬ `0.0.0.0:45000` åœ°å€ã€‚è¿™å¯èƒ½æ˜¯ä¸ºäº†ç‰¹å®šçš„ç›®çš„ï¼Œä¾‹å¦‚ç›‘æ§æˆ–å…¶ä»–æœåŠ¡ï¼Œä½†åœ¨æ­¤ä»£ç ç‰‡æ®µä¸­æ²¡æœ‰è¯¦ç»†è¯´æ˜ã€‚

3. **ä¸º websocket è¿æ¥è®¾ç½®è¯·æ±‚å¤„ç†å™¨**:

   ```go
   http.HandleFunc("/", ws.wsHandler)
   ```

   ä½¿ç”¨ `http.HandleFunc` æ–¹æ³•ä¸º root pathï¼ˆå³â€œ/â€ï¼‰è®¾ç½®äº†ä¸€ä¸ªå¤„ç†å‡½æ•° `ws.wsHandler`ã€‚å½“ HTTP æœåŠ¡å™¨æ”¶åˆ°ä¸€ä¸ªé’ˆå¯¹è¿™ä¸ªè·¯å¾„çš„è¯·æ±‚æ—¶ï¼Œå®ƒå°†ç”± `ws.wsHandler` æ–¹æ³•å¤„ç†ã€‚å¾ˆå¯èƒ½ï¼Œè¿™ä¸ªæ–¹æ³•ç”¨äºå¤„ç†æ¥è‡ªå®¢æˆ·ç«¯çš„ websocket è¿æ¥è¯·æ±‚ã€‚

4. **å¯åŠ¨ websocket æœåŠ¡å™¨**:

   ```go
   err := http.ListenAndServe(ws.wsAddr, nil)
   ```

   è¿™è¡Œä»£ç å¯åŠ¨äº†ä¸€ä¸ª HTTP æœåŠ¡å™¨ï¼Œç›‘å¬åœ¨ä¹‹å‰å®šä¹‰çš„ `ws.wsAddr` åœ°å€ä¸Šï¼ˆä¾‹å¦‚ `:10003`ï¼‰ã€‚ç”±äºå®ƒä¸åœ¨åç¨‹ä¸­ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªé˜»å¡æ€§è°ƒç”¨ï¼Œæ„å‘³ç€å®ƒä¼šé˜»å¡ç›´åˆ°æœåŠ¡å™¨åœæ­¢æˆ–å‘ç”Ÿé”™è¯¯ã€‚

5. **é”™è¯¯å¤„ç†**:

   ```bash
   if err != nil {
       log.Info("", "Ws listening err", "", "err", err.Error())
   }
   ```

   å¦‚æœ `http.ListenAndServe` è¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œè¿™æ®µä»£ç ä¼šè®°å½•è¯¥é”™è¯¯ã€‚åœ¨è¿™é‡Œï¼Œå®ƒä½¿ç”¨äº† `log.Info` æ–¹æ³•æ¥è¾“å‡ºé”™è¯¯ä¿¡æ¯ã€‚



**ç»§ç»­ï¼š**

```go
func (ws *WServer) getMsgAndSend() {
	defer func() {
		if r := recover(); r != nil {
			log.Info("", "getMsgAndSend panic", " panic is ", r, debug.Stack())
			ws.getMsgAndSend()
			log.Info("", "goroutine getMsgAndSend restart")
		}
	}()
	for {
		select {
		case r := <-ws.ch:
			go func() {
				operationID := utils2.OperationIDGenerator()
				log.Info(operationID, "getMsgAndSend channel: ", string(r.data), r.uid)

				//		conns := ws.getUserConn(r.uid + " " + "Web")
				conns := ws.getUserConn(r.uid + " " + utils.PlatformIDToName(sdk_struct.SvrConf.Platform))
				if conns == nil {
					log.Error(operationID, "uid no conn, failed ", r.uid+" "+utils.PlatformIDToName(sdk_struct.SvrConf.Platform))
					r.data = nil
				}
				log.Info(operationID, "conns  ", conns, r.uid+" "+utils.PlatformIDToName(sdk_struct.SvrConf.Platform))
				for _, conn := range conns {
					if conn != nil {
						err := WS.writeMsg(conn, websocket.TextMessage, r.data)
						if err != nil {
							log.Error(operationID, "WS WriteMsg error", "", "userIP", conn.RemoteAddr().String(), "userUid", r.uid, "error", err.Error())
						} else {
							log.Info(operationID, "writeMsg  ", conn.RemoteAddr(), string(r.data), r.uid)
						}
					} else {
						log.Error(operationID, "Conn is nil, failed")
					}
				}
				r.data = nil
			}()
		}
	}
}
```

1. **å¼‚å¸¸æ¢å¤**:

   ```go
   defer func() {
       if r := recover(); r != nil {
           // logging and restarting the goroutine
       }
   }()
   ```

   è¿™æ˜¯ä¸€ä¸ª`defer`è¯­å¥ä¸­çš„åŒ¿åå‡½æ•°ï¼Œå®ƒä¼šåœ¨`getMsgAndSend`æ–¹æ³•ç»“æŸæ—¶æ‰§è¡Œã€‚è¿™é‡Œçš„ç›®çš„æ˜¯æ•è·å’Œå¤„ç†ä»»ä½•åœ¨è¯¥æ–¹æ³•ä¸­äº§ç”Ÿçš„panicï¼Œé˜²æ­¢ç¨‹åºå´©æºƒã€‚å¦‚æœå‘ç”Ÿpanicï¼Œè¯¥å‡½æ•°å°†è®°å½•é”™è¯¯å¹¶å°è¯•é‡æ–°å¯åŠ¨`getMsgAndSend`æ–¹æ³•ã€‚

2. **æ— é™å¾ªç¯è·å–æ¶ˆæ¯**:

   ```go
   for {
   ```

   ä½¿ç”¨ä¸€ä¸ªæ— é™å¾ªç¯ç¡®ä¿æ–¹æ³•æŒç»­åœ°ä»é€šé“è·å–æ¶ˆæ¯ã€‚

3. **ä»é€šé“è·å–æ¶ˆæ¯**:

   ```go
   select {
   case r := <-ws.ch:
   ```

   ä½¿ç”¨`select`è¯­å¥ä»`ws.ch`é€šé“ä¸­è¯»å–æ¶ˆæ¯ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`select`åªæœ‰ä¸€ä¸ª`case`ï¼Œæ‰€ä»¥å®ƒå°†é˜»å¡ç›´åˆ°ä»`ws.ch`é€šé“ä¸­æ¥æ”¶åˆ°ä¸€ä¸ªæ¶ˆæ¯ã€‚

4. **å¤„ç†å’Œå‘é€æ¶ˆæ¯**:

   + ä¸ºæ¯ä¸ªæ¶ˆæ¯ç”Ÿæˆä¸€ä¸ªå”¯ä¸€çš„`operationID`ã€‚
   + ä»`ws.getUserConn`æ–¹æ³•è·å–ä¸æ¶ˆæ¯ç›¸å…³çš„æ‰€æœ‰websocketè¿æ¥ã€‚æœ`r.uid`æ˜¯"12345"ï¼Œ`sdk_struct.SvrConf.Platform`æ˜¯iOSçš„å¹³å°IDï¼Œé‚£ä¹ˆæœ€ç»ˆä¼ é€’ç»™`ws.getUserConn`çš„å­—ç¬¦ä¸²å¯èƒ½æ˜¯"12345 iOS"ã€‚
   + å¯¹äºæ¯ä¸ªwebsocketè¿æ¥ï¼Œä½¿ç”¨`WS.writeMsg`æ–¹æ³•å‘é€æ¶ˆæ¯ã€‚
   + å¦‚æœå‘é€æ¶ˆæ¯æ—¶å‡ºç°é”™è¯¯ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ã€‚
   + å¦‚æœè¿æ¥ä¸ºnilï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ã€‚

æ³¨æ„å‡ ä¸ªç‚¹ï¼š

+ ä½¿ç”¨äº†ä¸€ä¸ªå†…éƒ¨çš„goroutineï¼ˆ`go func() {...}`ï¼‰æ¥å¤„ç†å’Œå‘é€æ¯ä¸ªæ¶ˆæ¯ã€‚è¿™æ„å‘³ç€æ¶ˆæ¯çš„å‘é€æ˜¯å¹¶è¡Œæ‰§è¡Œçš„ï¼Œä¸ä¼šé˜»å¡å…¶ä»–æ¶ˆæ¯çš„å¤„ç†ã€‚
+ è¿™ä¸ªå‡½æ•°å…³å¿ƒçš„ä¸»è¦æ˜¯å°†æ¶ˆæ¯åˆ†å‘åˆ°æ­£ç¡®çš„websocketè¿æ¥ï¼Œè€Œä¸æ˜¯æ¶ˆæ¯çš„å†…å®¹æˆ–æ ¼å¼ã€‚
+ `r.data`æ˜¯æ¶ˆæ¯çš„å†…å®¹ï¼Œå®ƒæ˜¯ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ã€‚åœ¨å‘é€å®Œæ¶ˆæ¯åï¼Œå°†å…¶è®¾ä¸ºnilï¼Œå¯èƒ½æ˜¯ä¸ºäº†å¸®åŠ©åƒåœ¾æ”¶é›†å™¨å›æ”¶å†…å­˜ã€‚

**ç»§ç»­ï¼š**

```go
func PlatformIDToName(num int32) string {
	return PlatformID2Name[num]
}

var PlatformID2Name = map[int32]string{
	IOSPlatformID:     IOSPlatformStr,
	AndroidPlatformID: AndroidPlatformStr,
	WindowsPlatformID: WindowsPlatformStr,
	OSXPlatformID:     OSXPlatformStr,
	WebPlatformID:     WebPlatformStr,
	MiniWebPlatformID: MiniWebPlatformStr,
	LinuxPlatformID:   LinuxPlatformStr,
}
```

1. **PlatformIDToName å‡½æ•°**:

   ```go
   func PlatformIDToName(num int32) string {
       return PlatformID2Name[num]
   }
   ```

   è¿™æ˜¯ä¸€ä¸ªç®€å•çš„è¾…åŠ©å‡½æ•°ï¼Œå…¶æ¥å—ä¸€ä¸ª`int32`ç±»å‹çš„å¹³å°IDä½œä¸ºè¾“å…¥å‚æ•°ï¼Œå¹¶è¿”å›ä¸ä¹‹å¯¹åº”çš„å¹³å°åç§°ã€‚è¿™ä¸ªå‡½æ•°é€šè¿‡æŸ¥æ‰¾`PlatformID2Name`æ˜ å°„ï¼ˆmapï¼‰æ¥è·å–ç›¸åº”çš„å¹³å°åç§°ã€‚

2. **PlatformID2Name æ˜ å°„**:

   ```go
   var PlatformID2Name = map[int32]string{
       IOSPlatformID:     IOSPlatformStr,
       AndroidPlatformID: AndroidPlatformStr,
       ...
   }
   ```

   è¿™æ˜¯ä¸€ä¸ªå…¨å±€æ˜ å°„å˜é‡ï¼Œå…¶ä¸­çš„é”®æ˜¯`int32`ç±»å‹çš„å¹³å°IDï¼Œå€¼æ˜¯ç›¸åº”çš„å¹³å°åç§°å­—ç¬¦ä¸²ã€‚åœ¨ä»£ç ç‰‡æ®µä¸­ï¼Œå…·ä½“çš„IDå’Œåç§°çš„å€¼æ²¡æœ‰ç»™å‡ºï¼Œä½†ä»å˜é‡å‘½åå¯ä»¥æ¨æµ‹å®ƒä»¬åˆ†åˆ«ä»£è¡¨ä¸åŒçš„å¹³å°ï¼ˆå¦‚iOSã€Androidã€Windowsç­‰ï¼‰ã€‚



## wsHandler

ç»§ç»­ä»  wsHandler å¼€å§‹ï¼š

```go
func (ws *WServer) wsHandler(w http.ResponseWriter, r *http.Request) {
	operationID := utils2.OperationIDGenerator()
	defer func() {
		if r := recover(); r != nil {
			log.Info(operationID, "wsHandler panic recover", " panic is ", r)
			buf := make([]byte, 1<<20)
			runtime.Stack(buf, true)
			log.Info(operationID, "panic", "call", string(buf))
		}
	}()
	//var mem runtime.MemStats
	//runtime.ReadMemStats(&mem)
	//if mem.Alloc > 2*1024*1024*1024 {
	//	panic("Memory leak " + int64ToString(int64(mem.Alloc)))
	//}
	//log.Info(operationID, "wsHandler ", r.URL.Query(), "js sdk svr mem: ", mem.Alloc, mem.TotalAlloc, "all: ", mem)

	if ws.headerCheck(w, r, operationID) {
		query := r.URL.Query()
		conn, err := ws.wsUpGrader.Upgrade(w, r, nil) //Conn is obtained through the upgraded escalator
		if err != nil {
			log.Info(operationID, "upgrade http conn err", "", "err", err)
			return
		} else {

			sendIDAndPlatformID := query["sendID"][0] + " " + utils.PlatformIDToName(int32(utils.StringToInt64(query["platformID"][0])))
			newConn := &UserConn{conn, new(sync.Mutex)}
			ws.addUserConn(sendIDAndPlatformID, newConn, operationID)
			go ws.readMsg(newConn, sendIDAndPlatformID)
		}
	} else {
		log.NewError(operationID, "headerCheck failed")
	}
}

```

1. **å‡½æ•°å®šä¹‰**:

   ```go
   func (ws *WServer) wsHandler(w http.ResponseWriter, r *http.Request)
   ```

   è¿™æ˜¯ä¸€ä¸ªå±äº`WServer`ç»“æ„ä½“çš„æ–¹æ³•ã€‚è¯¥æ–¹æ³•æœ‰ä¸¤ä¸ªå‚æ•°ï¼šHTTPå“åº”å†™å…¥å™¨`w`å’ŒHTTPè¯·æ±‚`r`ã€‚

2. **å¤„ç†panic**: è¿™é‡Œçš„`defer`å‡½æ•°ä¸`recover`é…åˆï¼Œç”¨äºæ•è·å¹¶è®°å½•å‡½æ•°å†…éƒ¨çš„ä»»ä½•panicï¼Œç¡®ä¿æœåŠ¡çš„æ­£å¸¸è¿è¡Œã€‚

3. **å¤´éƒ¨æ£€æŸ¥(headerCheck)**:

   ```go
   if ws.headerCheck(w, r, operationID) {
   ```

   ä¹‹å‰ï¼Œ`headerCheck`å‡½æ•°å¯èƒ½ç”¨äºéªŒè¯æ¥è‡ªå®¢æˆ·ç«¯çš„è¯·æ±‚å¤´éƒ¨æ˜¯å¦æ»¡è¶³æŸäº›è¦æ±‚æˆ–åŒ…å«æœ‰æ•ˆçš„ä»¤ç‰Œã€‚åªæœ‰å½“æ­¤æ£€æŸ¥é€šè¿‡æ—¶ï¼Œä»£ç æ‰ä¼šç»§ç»­æ‰§è¡Œåç»­é€»è¾‘ã€‚

4. **å‡çº§HTTPè¿æ¥ä¸ºWebSocket**:

   ```go
   conn, err := ws.wsUpGrader.Upgrade(w, r, nil)
   ```

   ä½¿ç”¨`wsUpGrader`ï¼Œè¯¥ä»£ç å°è¯•å°†HTTPè¯·æ±‚å‡çº§ä¸ºWebSocketè¿æ¥ã€‚

5. **å¤„ç†WebSocketè¿æ¥**:

   + å¦‚æœå‡çº§å¤±è´¥ï¼Œåˆ™è®°å½•é”™è¯¯å¹¶è¿”å›ã€‚
   + å¦‚æœæˆåŠŸï¼Œå®ƒå°†è·å–`sendID`å’Œ`platformID`æ¥è¯†åˆ«ç”¨æˆ·ï¼Œå¹¶ç»„åˆå®ƒä»¬ä»¥åˆ›å»ºä¸€ä¸ªå”¯ä¸€æ ‡è¯†ç¬¦`sendIDAndPlatformID`ã€‚
   + åˆ›å»ºä¸€ä¸ªæ–°çš„`UserConn`ç»“æ„ä½“å®ä¾‹ï¼Œè¡¨ç¤ºç”¨æˆ·çš„WebSocketè¿æ¥ã€‚
   + ä½¿ç”¨`addUserConn`æ–¹æ³•å°†æ–°çš„WebSocketè¿æ¥æ·»åŠ åˆ°å†…éƒ¨æ•°æ®ç»“æ„ä¸­ã€‚
   + ä½¿ç”¨`readMsg`æ–¹æ³•åœ¨æ–°çš„goroutineä¸­å¼‚æ­¥è¯»å–æ¥è‡ªè¯¥WebSocketè¿æ¥çš„æ¶ˆæ¯ã€‚

6. **å¦‚æœå¤´éƒ¨æ£€æŸ¥å¤±è´¥**: å¦‚æœ`headerCheck`å¤±è´¥ï¼Œå®ƒå°†è®°å½•ä¸€æ¡é”™è¯¯æ¶ˆæ¯ã€‚



**ç»§ç»­è¿›è¡Œ headerCheck:**

```go
func (ws *WServer) headerCheck(w http.ResponseWriter, r *http.Request, operationID string) bool {

	status := http.StatusUnauthorized
	query := r.URL.Query()
	log.Info(operationID, "headerCheck: ", query["token"], query["platformID"], query["sendID"], r.RemoteAddr)
	if len(query["token"]) != 0 && len(query["sendID"]) != 0 && len(query["platformID"]) != 0 {
		SendID := query["sendID"][0] + " " + utils.PlatformIDToName(int32(utils.StringToInt64(query["platformID"][0])))
		if ws.getConnNum(SendID) >= POINTNUM {
			log.Info(operationID, "Over quantity failed", query, ws.getConnNum(SendID), SendID)
			w.Header().Set("Sec-Websocket-Version", "13")
			http.Error(w, "Over quantity", status)
			return false
		}
		//if utils.StringToInt(query["platformID"][0]) != utils.WebPlatformID {
		//	log.Info("check platform id failed", query["sendID"][0], query["platformID"][0])
		//	w.Header().Set("Sec-Websocket-Version", "13")
		//	http.Error(w, http.StatusText(status), StatusBadRequest)
		//	return false
		//}
		checkFlag := open_im_sdk.CheckToken(query["sendID"][0], query["token"][0], operationID)
		if checkFlag != nil {
			log.Info(operationID, "check token failed", query["sendID"][0], query["token"][0], checkFlag.Error())
			w.Header().Set("Sec-Websocket-Version", "13")
			http.Error(w, http.StatusText(status), status)
			return false
		}
		log.Info(operationID, "Connection Authentication Success", "", "token", query["token"][0], "userID", query["sendID"][0], "platformID", query["platformID"][0])
		return true

	} else {
		log.Info(operationID, "Args err", "", "query", query)
		w.Header().Set("Sec-Websocket-Version", "13")
		http.Error(w, http.StatusText(status), StatusBadRequest)
		return false
	}
}
```

1. **å‡½æ•°å®šä¹‰**:

   ```go
   func (ws *WServer) headerCheck(w http.ResponseWriter, r *http.Request, operationID string) bool
   ```

   è¿™æ˜¯ä¸€ä¸ªå±äº`WServer`ç»“æ„ä½“çš„æ–¹æ³•ã€‚è¯¥æ–¹æ³•æœ‰ä¸‰ä¸ªå‚æ•°ï¼šHTTPå“åº”å†™å…¥å™¨`w`ã€HTTPè¯·æ±‚`r`ï¼Œä»¥åŠ`operationID`ï¼Œä¸€ä¸ªç”¨äºæ—¥å¿—è®°å½•çš„æ ‡è¯†ç¬¦ã€‚

2. **æ—¥å¿—è®°å½•**:

   ```go
   log.Info(operationID, "headerCheck: ", query["token"], query["platformID"], query["sendID"], r.RemoteAddr)
   ```

   ä¸ºäº†æ–¹ä¾¿è·Ÿè¸ªå’Œè°ƒè¯•ï¼Œè¯¥æ–¹æ³•é¦–å…ˆè®°å½•äº†ä¼ å…¥è¯·æ±‚çš„ä¸€äº›å‚æ•°ã€‚

3. **éªŒè¯æŸ¥è¯¢å‚æ•°**: è¯¥æ–¹æ³•æ£€æŸ¥è¯·æ±‚URLçš„æŸ¥è¯¢å‚æ•°ä¸­æ˜¯å¦å­˜åœ¨`token`, `sendID`å’Œ`platformID`ã€‚è¿™äº›å‚æ•°æ˜¯WebSocketè¿æ¥çš„å¿…éœ€å‚æ•°ã€‚

4. **æ£€æŸ¥è¿æ¥æ•°é‡**:

   ```go
   if ws.getConnNum(SendID) >= POINTNUM
   ```

   æ­¤å¤„é™åˆ¶äº†ä¸ç‰¹å®šç”¨æˆ·å…³è”çš„WebSocketè¿æ¥æ•°ã€‚å¦‚æœè¶…è¿‡äº†é™åˆ¶(`POINTNUM`)ï¼Œåˆ™è¿”å›é”™è¯¯ã€‚

5. **éªŒè¯å¹³å°ID**: è™½ç„¶ä»£ç ä¸­æ³¨é‡Šæ‰äº†æ­¤éƒ¨åˆ†ï¼Œä½†åŸæ¥çš„æ„å›¾æ˜¯æ£€æŸ¥`platformID`æ˜¯å¦ç­‰äºç‰¹å®šçš„å¹³å°IDï¼Œä¾‹å¦‚Webã€‚

6. **TokenéªŒè¯**:

   ```go
   checkFlag := open_im_sdk.CheckToken(query["sendID"][0], query["token"][0], operationID)
   ```

   ä½¿ç”¨æä¾›çš„SDKå‡½æ•°`CheckToken`æ¥éªŒè¯ç”¨æˆ·çš„`token`ã€‚

7. **å¤„ç†å¤±è´¥çš„è¯·æ±‚**: å¦‚æœéªŒè¯å¤±è´¥ï¼Œè¯¥æ–¹æ³•å°†åœ¨å“åº”å¤´éƒ¨è®¾ç½®`Sec-Websocket-Version`å¹¶å‘é€ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ã€‚

8. **è¿”å›å€¼**: æ–¹æ³•æœ€åè¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè¡¨ç¤ºè¯·æ±‚æ˜¯å¦å·²æˆåŠŸéªŒè¯ã€‚

æ€»ç»“ï¼š`headerCheck`æ–¹æ³•çš„ä¸»è¦ç›®çš„æ˜¯éªŒè¯WebSocketè¿æ¥è¯·æ±‚ã€‚å®ƒç¡®ä¿è¯·æ±‚å…·æœ‰æ‰€æœ‰å¿…è¦çš„æŸ¥è¯¢å‚æ•°ï¼Œå¹¶ä¸”è¿™äº›å‚æ•°éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚å¦‚æœæ‰€æœ‰æ£€æŸ¥éƒ½é€šè¿‡ï¼Œåˆ™è¯¥è¯·æ±‚è¢«è®¤ä¸ºæ˜¯æœ‰æ•ˆçš„ï¼Œæ–¹æ³•å°†è¿”å›`true`ï¼›å¦åˆ™è¿”å›`false`ã€‚

ç»§ç»­çœ‹çœ‹æ£€æŸ¥ tokenï¼š

```go

func CheckToken(userID, token string, operationID string) (error, uint32) {
	if operationID == "" {
		operationID = utils.OperationIDGenerator()
	}
	log.Debug(operationID, utils.GetSelfFuncName(), userID, token)
	p := ws.NewPostApi(token, sdk_struct.SvrConf.ApiAddr)
	user := user.NewUser(nil, p, userID, nil)
	//_, err := user.GetSelfUserInfoFromSvr(operationID)
	//if err != nil {
	//	return utils.Wrap(err, "GetSelfUserInfoFromSvr failed "+operationID), 0
	//}
	exp, err := user.ParseTokenFromSvr(operationID)
	return err, exp
}
```

1. **å‡½æ•°å®šä¹‰**:

   ```go
   func CheckToken(userID, token string, operationID string) (error, uint32)
   ```

   æ­¤å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šç”¨æˆ·ID(`userID`)ã€token(`token`)å’Œç”¨äºæ—¥å¿—è®°å½•çš„æ“ä½œID(`operationID`)ã€‚å®ƒè¿”å›ä¸€ä¸ªé”™è¯¯å¯¹è±¡å’Œä¸€ä¸ªæ— ç¬¦å·çš„32ä½æ•´æ•°ã€‚

2. **ç”Ÿæˆæ“ä½œID**:

   ```go
   if operationID == "" {
       operationID = utils.OperationIDGenerator()
   }
   ```

   å¦‚æœä¼ å…¥çš„æ“ä½œIDæ˜¯ç©ºçš„ï¼Œåˆ™ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„æ“ä½œIDã€‚

3. **æ—¥å¿—è®°å½•**:

   ```go
   log.Debug(operationID, utils.GetSelfFuncName(), userID, token)
   ```

   è®°å½•è°ƒè¯•ä¿¡æ¯ï¼ŒåŒ…æ‹¬å‡½æ•°åå’Œä¼ å…¥çš„å‚æ•°ã€‚

4. **åˆ›å»ºPost APIå’Œç”¨æˆ·å¯¹è±¡**:

   ```go
   p := ws.NewPostApi(token, sdk_struct.SvrConf.ApiAddr)
   user := user.NewUser(nil, p, userID, nil)
   ```

   ä¸ºäº†è¿›ä¸€æ­¥ä¸æœåŠ¡å™¨é€šä¿¡ï¼Œè¿™é‡Œé¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„Post APIå¯¹è±¡ã€‚ç„¶åï¼Œä½¿ç”¨è¯¥APIå¯¹è±¡åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ç”¨æˆ·å¯¹è±¡ã€‚

   > APIè¯·æ±‚çš„ä¸€ç§å¸¸è§æ–¹å¼æ˜¯ä½¿ç”¨HTTP POSTè¯·æ±‚ã€‚è¿™ç§è¯·æ±‚å¯ä»¥å‘é€æ•°æ®ï¼ˆä¾‹å¦‚ç”¨æˆ·åå’Œå¯†ç ï¼‰åˆ°æœåŠ¡å™¨ï¼Œå¹¶æœŸæœ›è¿”å›æŸäº›æ•°æ®ï¼ˆä¾‹å¦‚ç”¨æˆ·çš„è¯¦ç»†ä¿¡æ¯ï¼‰ã€‚
   >
   > åœ¨ç»™å®šçš„ä»£ç ä¸­ï¼Œ`ws.NewPostApi(token, sdk_struct.SvrConf.ApiAddr)`å¾ˆå¯èƒ½æ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„APIå®¢æˆ·ç«¯çš„æ–¹æ³•ï¼Œç”¨äºå‘åœ°å€`sdk_struct.SvrConf.ApiAddr`å‘é€POSTè¯·æ±‚ï¼Œå¹¶ä½¿ç”¨`token`è¿›è¡Œèº«ä»½éªŒè¯ã€‚

5. **TokenéªŒè¯**: è™½ç„¶å·²ç»æ³¨é‡Šæ‰äº†è¿™éƒ¨åˆ†ä»£ç ï¼Œä½†åŸæ„æ˜¯é€šè¿‡`GetSelfUserInfoFromSvr`æ–¹æ³•ä»æœåŠ¡å™¨è·å–ç”¨æˆ·ä¿¡æ¯æ¥éªŒè¯tokenã€‚æ­¤éªŒè¯å·²è¢«æ–°çš„`ParseTokenFromSvr`æ–¹æ³•æ›¿ä»£ã€‚

6. **è§£æToken**:

   ```go
   exp, err := user.ParseTokenFromSvr(operationID)
   ```

   ä½¿ç”¨`ParseTokenFromSvr`æ–¹æ³•è§£ætokenã€‚è¿™å¯èƒ½æ˜¯ä¸ºäº†æ£€æŸ¥tokenæ˜¯å¦è¿˜æœ‰æ•ˆæˆ–æ˜¯å¦ä¸ç»™å®šçš„ç”¨æˆ·IDåŒ¹é…ã€‚

7. **è¿”å›å€¼**: å‡½æ•°æœ€åè¿”å›ç”±`ParseTokenFromSvr`æ–¹æ³•äº§ç”Ÿçš„é”™è¯¯å’Œæ— ç¬¦å·çš„32ä½æ•´æ•°å€¼ã€‚



**ç»§ç»­çœ‹ Parse Token éƒ¨åˆ†ï¼š**

```go
func (u *User) ParseTokenFromSvr(operationID string) (uint32, error) {
	apiReq := api.ParseTokenReq{}
	apiReq.OperationID = operationID
	apiResp := api.ParseTokenResp{}
	err := u.p.PostReturn(constant.ParseTokenRouter, apiReq, &apiResp.ExpireTime)
	if err != nil {
		return 0, utils.Wrap(err, apiReq.OperationID)
	}
	log.Info(operationID, "apiResp.ExpireTime.ExpireTimeSeconds ", apiResp.ExpireTime)
	return apiResp.ExpireTime.ExpireTimeSeconds, nil
}

```

æ­¤ä»£ç ç‰‡æ®µå®šä¹‰äº†`User`ç»“æ„çš„æ–¹æ³•`ParseTokenFromSvr`ï¼Œå®ƒæ—¨åœ¨ä¸æœåŠ¡å™¨é€šä¿¡ä»¥è§£æï¼ˆæˆ–éªŒè¯ï¼‰ä»¤ç‰Œã€‚ä¸‹é¢æ˜¯è¯¥å‡½æ•°çš„è¯¦ç»†æ­¥éª¤åŠè§£é‡Šï¼š

1. **å‡½æ•°ç­¾å**:

   ```go
   func (u *User) ParseTokenFromSvr(operationID string) (uint32, error)
   ```

   è¿™æ˜¯ä¸€ä¸ª`User`ç»“æ„çš„æ–¹æ³•ã€‚å®ƒæ¥å—ä¸€ä¸ªåä¸º`operationID`çš„å­—ç¬¦ä¸²å‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ª`uint32`ç±»å‹çš„å€¼å’Œä¸€ä¸ª`error`ã€‚

2. **åˆ›å»ºè¯·æ±‚å¯¹è±¡**:

   ```go
   apiReq := api.ParseTokenReq{}
   ```

   è¯¥ä»£ç åˆå§‹åŒ–ä¸€ä¸ªåä¸º`apiReq`çš„`ParseTokenReq`ç±»å‹çš„å¯¹è±¡ã€‚è¿™ä¸ªå¯¹è±¡å¾ˆå¯èƒ½æ˜¯ç”¨äºAPIè°ƒç”¨çš„è¯·æ±‚ä½“ã€‚

3. **è®¾ç½®æ“ä½œID**:

   ```go
   apiReq.OperationID = operationID
   ```

   å°†ä¼ é€’ç»™å‡½æ•°çš„`operationID`åˆ†é…ç»™`apiReq`çš„`OperationID`å­—æ®µã€‚

4. **åˆ›å»ºå“åº”å¯¹è±¡**:

   ```go
   apiResp := api.ParseTokenResp{}
   ```

   æ­¤ä»£ç åˆå§‹åŒ–ä¸€ä¸ªé¢„æœŸçš„APIå“åº”å¯¹è±¡ã€‚æ­¤å¯¹è±¡å°†è¢«å¡«å……ï¼Œå½“æœåŠ¡å™¨å“åº”APIè¯·æ±‚æ—¶ã€‚

5. **APIè¯·æ±‚**:

   ```go
   err := u.p.PostReturn(constant.ParseTokenRouter, apiReq, &apiResp.ExpireTime)
   ```

   ä½¿ç”¨`PostReturn`æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å‘é€ä¸€ä¸ªPOSTè¯·æ±‚åˆ°æœåŠ¡å™¨ã€‚å®ƒéœ€è¦ä¸‰ä¸ªå‚æ•°ï¼š

   + `constant.ParseTokenRouter`ï¼šAPIçš„è·¯ç”±æˆ–ç«¯ç‚¹ã€‚
   + `apiReq`ï¼šè¯·æ±‚çš„æ•°æ®ã€‚
   + `&apiResp.ExpireTime`ï¼šå“åº”çš„æ•°æ®åº”è¢«å¡«å……åœ¨è¿™é‡Œã€‚

6. **é”™è¯¯æ£€æŸ¥**:

   ```go
   if err != nil {
      return 0, utils.Wrap(err, apiReq.OperationID)
   }
   ```

   å¦‚æœåœ¨APIè¯·æ±‚ä¸­å‡ºç°é”™è¯¯ï¼Œå°†é”™è¯¯åŒ…è£…ï¼ˆä½¿ç”¨`utils.Wrap`å‡½æ•°ï¼‰å¹¶è¿”å›ã€‚

7. **è®°å½•å“åº”**:

   ```go
   log.Info(operationID, "apiResp.ExpireTime.ExpireTimeSeconds ", apiResp.ExpireTime)
   ```

   å°†APIå“åº”è®°å½•åˆ°æ—¥å¿—ä¸­ã€‚

8. **è¿”å›ç»“æœ**:

   ```go
   return apiResp.ExpireTime.ExpireTimeSeconds, nil
   ```

   è¿”å›ä»æœåŠ¡å™¨è·å–çš„åˆ°æœŸæ—¶é—´ã€‚å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œç¬¬äºŒä¸ªè¿”å›å€¼å°†ä¸º`nil`ã€‚

è¿™ä¸ªå‡½æ•°çš„ç›®çš„æ˜¯ä¸æœåŠ¡å™¨é€šä¿¡ï¼ŒéªŒè¯ï¼ˆæˆ–è§£æï¼‰ä»¤ç‰Œï¼Œå¹¶ä»æœåŠ¡å™¨è·å–ä»¤ç‰Œçš„åˆ°æœŸæ—¶é—´ã€‚



**OperationID;**

`operationID` æ˜¯ä¸€ä¸ªé€šå¸¸åœ¨æ—¥å¿—ã€ç›‘æ§ã€è°ƒè¯•å’Œè·Ÿè¸ªä¸­ä½¿ç”¨çš„æ ‡è¯†ç¬¦ã€‚å®ƒçš„ç›®çš„æ˜¯åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­æä¾›ä¸€ä¸ªç‹¬ç‰¹çš„ã€å¯è¯†åˆ«çš„æ ‡è®°ï¼Œä½¿å¾—ç‰¹å®šçš„æ“ä½œæˆ–è¯·æ±‚å¯ä»¥è·¨å¤šä¸ªç»„ä»¶ã€æœåŠ¡æˆ–æ—¥å¿—æ¡ç›®è¿›è¡Œè¿½è¸ªã€‚

åœ¨ç»™å®šçš„ä»£ç ä¸­ï¼Œ`operationID` è¢«ç”¨ä½œä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œå…¶å€¼éšè¯·æ±‚è¢«ä¼ é€’ï¼Œå¹¶å¯èƒ½è¢«ç”¨äºæ—¥å¿—è®°å½•æˆ–é”™è¯¯å¤„ç†ã€‚è¿™ç§æ–¹å¼ä½¿å¾—å¼€å‘äººå‘˜å’Œè¿ç»´äººå‘˜èƒ½å¤Ÿè½»æ¾åœ°è·Ÿè¸ªæˆ–æŸ¥æ‰¾ä¸ç‰¹å®šè¯·æ±‚æˆ–æ“ä½œç›¸å…³çš„æ‰€æœ‰æ´»åŠ¨æˆ–é—®é¢˜ã€‚

ä½¿ç”¨ `operationID` çš„ä¼˜åŠ¿åŒ…æ‹¬ï¼š

1. **è·Ÿè¸ªèƒ½åŠ›**ï¼šåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œä¸€ä¸ªè¯·æ±‚å¯èƒ½ä¼šç©¿è¶Šå¤šä¸ªæœåŠ¡æˆ–ç»„ä»¶ã€‚ä½¿ç”¨å”¯ä¸€çš„ `operationID` å¯ä»¥å¸®åŠ©ä½ è·Ÿè¸ªæ•´ä¸ªè¯·æ±‚çš„ç”Ÿå‘½å‘¨æœŸã€‚
2. **ç®€åŒ–é—®é¢˜è¯Šæ–­**ï¼šå½“é—®é¢˜å‘ç”Ÿæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `operationID` å¿«é€Ÿå®šä½æ‰€æœ‰ä¸ç‰¹å®šè¯·æ±‚æˆ–æ“ä½œç›¸å…³çš„æ—¥å¿—æ¡ç›®ï¼Œä»è€Œæ›´å®¹æ˜“åœ°ç¡®å®šé—®é¢˜çš„æ ¹æºã€‚
3. **æé«˜æ—¥å¿—çš„æœ‰ç”¨æ€§**ï¼š`operationID` å¯ä»¥å¸®åŠ©å°†ç›¸å…³çš„æ—¥å¿—æ¡ç›®åˆ†ç»„ï¼Œä½¿å…¶æ›´å®¹æ˜“åˆ†æã€‚

åœ¨ç»™å®šçš„ä»£ç ä¸­ï¼Œä¼¼ä¹ `operationID` è¢«ç”¨äºæ—¥å¿—è®°å½•ï¼Œä»è€Œèƒ½å¤Ÿè·Ÿè¸ªè¯·æ±‚ã€æ“ä½œæˆ–ç‰¹å®šçš„



**ç»§ç»­çœ‹ headcheck æ£€æŸ¥æˆåŠŸéƒ¨åˆ†ï¼š**

```go
sendIDAndPlatformID := query["sendID"][0] + " " + utils.PlatformIDToName(int32(utils.StringToInt64(query["platformID"][0])))
newConn := &UserConn{conn, new(sync.Mutex)}
ws.addUserConn(sendIDAndPlatformID, newConn, operationID)
go ws.readMsg(newConn, sendIDAndPlatformID)
```



**æ·»åŠ ç”¨æˆ·é“¾æ¥ï¼š**

```go
func (ws *WServer) addUserConn(uid string, conn *UserConn, operationID string) {
	rwLock.Lock()

	var flag int32
	if oldConnMap, ok := ws.wsUserToConn[uid]; ok {
		flag = 1
		oldConnMap[conn.RemoteAddr().String()] = conn
		ws.wsUserToConn[uid] = oldConnMap
		log.Info(operationID, "this user is not first login", "", "uid", uid)
		//err := oldConn.Close()
		//delete(ws.wsConnToUser, oldConn)
		//if err != nil {
		//	log.Info("", "close err", "", "uid", uid, "conn", conn)
		//}
	} else {
		i := make(map[string]*UserConn)
		i[conn.RemoteAddr().String()] = conn
		ws.wsUserToConn[uid] = i
		log.Info(operationID, "this user is first login", "", "uid", uid)
	}
	if oldStringMap, ok := ws.wsConnToUser[conn]; ok {
		oldStringMap[conn.RemoteAddr().String()] = uid
		ws.wsConnToUser[conn] = oldStringMap
		log.Info(operationID, "find failed", "", "uid", uid)
		//err := oldConn.Close()
		//delete(ws.wsConnToUser, oldConn)
		//if err != nil {
		//	log.Info("", "close err", "", "uid", uid, "conn", conn)
		//}
	} else {
		i := make(map[string]string)
		i[conn.RemoteAddr().String()] = uid
		ws.wsConnToUser[conn] = i
		log.Info(operationID, "this user is first login", "", "uid", uid)
	}
	log.Info(operationID, "WS Add operation", "", "wsUser added", ws.wsUserToConn, "uid", uid, "online_num", len(ws.wsUserToConn))
	rwLock.Unlock()

	//log.Info("", "after add, wsConnToUser map ", ws.wsConnToUser)
	//	log.Info("", "after add, wsUserToConn  map ", ws.wsUserToConn)

	if flag == 1 {
		//	DelUserRouter(uid)
	}

}
```

è¿™æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä¸»è¦ç”¨äºå¤„ç† WebSocket æœåŠ¡å™¨ä¸­ç”¨æˆ·è¿æ¥çš„æ·»åŠ é€»è¾‘ã€‚æˆ‘ä»¬æ¥é€è¡Œè§£æå®ƒã€‚

é¦–å…ˆï¼Œå£°æ˜å‡½æ•°ï¼š

```go
func (ws *WServer) addUserConn(uid string, conn *UserConn, operationID string) {
```

è¿™æ˜¯ä¸€ä¸ªæ–¹æ³•ï¼Œå…¶æ¥æ”¶è€…ç±»å‹ä¸º `*WServer`ï¼Œæ–¹æ³•åä¸º `addUserConn`ã€‚è¯¥æ–¹æ³•æ¥å—ä¸‰ä¸ªå‚æ•°ï¼š`uid`ï¼ˆç”¨æˆ·IDï¼‰ï¼Œ`conn`ï¼ˆç”¨æˆ·è¿æ¥ä¿¡æ¯ï¼‰å’Œ`operationID`ï¼ˆæ“ä½œIDï¼Œå¯èƒ½ç”¨äºæ—¥å¿—è®°å½•ï¼‰ã€‚

æ¥ä¸‹æ¥ï¼š

```go
rwLock.Lock()
```

å®ƒç”¨ä¸€ä¸ªè¯»å†™é”ï¼ˆ`rwLock`ï¼‰æ¥åŠ é”ï¼Œä¿è¯åœ¨å¯¹æ•°æ®ç»“æ„è¿›è¡Œä¿®æ”¹æ—¶ä¸ä¼šå‘ç”Ÿå¹¶å‘å†²çªã€‚

```go
var flag int32
```

å®šä¹‰äº†ä¸€ä¸ª `flag` å˜é‡ï¼Œåˆå§‹åŒ–ä¸º0ã€‚æ­¤å˜é‡ç¨åç”¨äºæ ‡è®°æŸäº›æƒ…å†µã€‚

æ¥ä¸‹æ¥æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç»å­˜åœ¨ï¼š

```go
if oldConnMap, ok := ws.wsUserToConn[uid]; ok {
```

å¦‚æœç”¨æˆ· `uid` å·²ç»åœ¨ `wsUserToConn` æ˜ å°„ä¸­ï¼Œåˆ™ `ok` ä¸º `true`ã€‚

```go
flag = 1
```

å°† `flag` è®¾ä¸º1ï¼Œè¡¨ç¤ºç”¨æˆ·ä¸æ˜¯é¦–æ¬¡ç™»å½•ã€‚

æ¥ç€ï¼Œå‡½æ•°æ›´æ–°è¯¥ç”¨æˆ·çš„è¿æ¥æ˜ å°„ï¼Œå¹¶è®°å½•æ—¥å¿—ï¼š

```go
oldConnMap[conn.RemoteAddr().String()] = conn
ws.wsUserToConn[uid] = oldConnMap
log.Info(operationID, "this user is not first login", "", "uid", uid)
```

æ³¨é‡Šéƒ¨åˆ†ä¼¼ä¹æ˜¯ä¹‹å‰çš„ä¸€äº›é€»è¾‘ï¼Œç°åœ¨å·²è¢«æ³¨é‡Šæ‰ï¼š

```go
//err := oldConn.Close()
//delete(ws.wsConnToUser, oldConn)
//if err != nil {
//	log.Info("", "close err", "", "uid", uid, "conn", conn)
//}
```

å¦‚æœç”¨æˆ· `uid` ä¸åœ¨ `wsUserToConn` æ˜ å°„ä¸­ï¼Œé‚£ä¹ˆå°†åˆ›å»ºæ–°çš„æ˜ å°„ï¼Œå¹¶è®°å½•æ—¥å¿—ï¼š

```go
} else {
	i := make(map[string]*UserConn)
	i[conn.RemoteAddr().String()] = conn
	ws.wsUserToConn[uid] = i
	log.Info(operationID, "this user is first login", "", "uid", uid)
}
```

æ¥ç€ï¼Œæ£€æŸ¥å½“å‰è¿æ¥æ˜¯å¦å·²å­˜åœ¨ï¼š

```go
if oldStringMap, ok := ws.wsConnToUser[conn]; ok {
```

å¦‚æœå­˜åœ¨ï¼Œæ›´æ–°æ˜ å°„å¹¶è®°å½•æ—¥å¿—ï¼š

```go
oldStringMap[conn.RemoteAddr().String()] = uid
ws.wsConnToUser[conn] = oldStringMap
log.Info(operationID, "find failed", "", "uid", uid)
```

åŒæ ·ï¼Œæ³¨é‡Šéƒ¨åˆ†æ˜¯ä¸€äº›ä¹‹å‰çš„é€»è¾‘ã€‚

å¦‚æœè¿æ¥ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°çš„æ˜ å°„å¹¶è®°å½•æ—¥å¿—ï¼š

```go
} else {
	i := make(map[string]string)
	i[conn.RemoteAddr().String()] = uid
	ws.wsConnToUser[conn] = i
	log.Info(operationID, "this user is first login", "", "uid", uid)
}
```

ä¹‹åï¼Œè®°å½•ä¸€æ¡æ€»ä½“çš„æ—¥å¿—ä¿¡æ¯ï¼š

```go
log.Info(operationID, "WS Add operation", "", "wsUser added", ws.wsUserToConn, "uid", uid, "online_num", len(ws.wsUserToConn))
```

ç„¶åè§£é”ï¼š

```go
rwLock.Unlock()
```

æœ€åï¼Œæ ¹æ®ä¹‹å‰çš„ `flag` åˆ¤æ–­ï¼Œå¦‚æœç”¨æˆ·ä¸æ˜¯é¦–æ¬¡ç™»å½•ï¼Œå¯èƒ½éœ€è¦æ‰§è¡Œä¸€äº›é¢å¤–çš„æ“ä½œï¼ˆè¿™é‡Œä¹Ÿè¢«æ³¨é‡Šæ‰äº†ï¼‰ï¼š

```go
if flag == 1 {
	//	DelUserRouter(uid)
}
```

æ•´ä½“ä¸Šï¼Œè¿™ä¸ªå‡½æ•°çš„ç›®çš„æ˜¯åœ¨ WebSocket æœåŠ¡å™¨ä¸­æ·»åŠ æˆ–æ›´æ–°ç”¨æˆ·è¿æ¥ã€‚



**ä» WebSockets ä¸æ–­è¯»å–é“¾æ¥ï¼š**

```go

func (ws *WServer) readMsg(conn *UserConn, sendIDAndPlatformID string) {
	for {
		msgType, msg, err := conn.ReadMessage()
		if err != nil {
			log.Info("", "ReadMessage error", "", "userIP", conn.RemoteAddr().String(), "userUid", sendIDAndPlatformID, "error", err.Error())

			//log.Info("debug memory delUserConn begin ")
			//time.Sleep(1 * time.Second)

			ws.delUserConn(conn)
			//log.Info("debug memory delUserConn end  ")
			//time.Sleep(1 * time.Second)
			return
		} else {
			log.Info("", "ReadMessage ok ", "", "msgType", msgType, "userIP", conn.RemoteAddr().String(), "userUid", sendIDAndPlatformID)
		}
		m := Req{}
		json.Unmarshal(msg, &m)

		//log.Info("debug memory msgParse begin ", m)
		//time.Sleep(1 * time.Second)

		ws.msgParse(conn, msg)
		//log.Info("debug memory msgParse end ", m)
		//time.Sleep(1 * time.Second)
	}
}

```

è¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ªæ–¹æ³• `readMsg`ï¼Œå…¶æ¥æ”¶è€…ç±»å‹ä¸º `*WServer`ã€‚è¿™ä¸ªæ–¹æ³•çš„ä¸»è¦ç›®çš„æ˜¯ä»ä¸€ä¸ª `UserConn`ï¼ˆä¼¼ä¹æ˜¯ä¸€ä¸ª WebSocket è¿æ¥ï¼‰ä¸­ä¸æ–­åœ°è¯»å–æ¶ˆæ¯ã€‚

è®©æˆ‘ä»¬ç»§ç»­é€è¡Œåˆ†æï¼š

```
func (ws *WServer) readMsg(conn *UserConn, sendIDAndPlatformID string) {
```

è¯¥æ–¹æ³•æ¥å—ä¸¤ä¸ªå‚æ•°ï¼š`conn`ï¼ˆç”¨æˆ·è¿æ¥ä¿¡æ¯ï¼‰å’Œ `sendIDAndPlatformID`ï¼ˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¯èƒ½åŒ…å«å‘é€è€…IDå’Œå¹³å°IDï¼Œä½†ä»è¿™ä¸ªåç§°æ¥çœ‹ï¼Œå…·ä½“å«ä¹‰ä¸å¤ªæ˜ç¡®ï¼‰ã€‚

å¼€å§‹æ— é™å¾ªç¯ï¼Œæ„å‘³ç€å®ƒä¼šæŒç»­åœ°è¯»å–æ¶ˆæ¯ï¼Œç›´åˆ°å‘ç”Ÿé”™è¯¯æˆ–å…¶ä»–é€€å‡ºæ¡ä»¶ï¼š

```
for {
```

å°è¯•ä» `conn` è¯»å–æ¶ˆæ¯ï¼š

```
msgType, msg, err := conn.ReadMessage()
```

æ£€æŸ¥æ˜¯å¦å‡ºç°è¯»å–é”™è¯¯ï¼š

```
if err != nil {
```

å¦‚æœå‡ºç°é”™è¯¯ï¼Œè®°å½•é”™è¯¯æ—¥å¿—ï¼š

```go
log.Info("", "ReadMessage error", "", "userIP", conn.RemoteAddr().String(), "userUid", sendIDAndPlatformID, "error", err.Error())
```

æ¥ç€ï¼Œåˆ é™¤è¯¥ç”¨æˆ·è¿æ¥ï¼š

```
ws.delUserConn(conn)
```

æ­¤å¤„è¿˜æœ‰ä¸€äº›è¢«æ³¨é‡Šæ‰çš„ä»£ç ï¼Œçœ‹èµ·æ¥åƒæ˜¯ä¹‹å‰ç”¨äºè°ƒè¯•å†…å­˜é—®é¢˜çš„ï¼š

```
//log.Info("debug memory delUserConn begin ")
//time.Sleep(1 * time.Second)
//...
//log.Info("debug memory delUserConn end  ")
//time.Sleep(1 * time.Second)
```

å› ä¸ºè¯»å–æ¶ˆæ¯å‡ºé”™ï¼Œæ‰€ä»¥ç›´æ¥è¿”å›ï¼Œç»“æŸå‡½æ•°ï¼š

```
return
```

å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œåˆ™è®°å½•æ—¥å¿—ï¼š

```
} else {
	log.Info("", "ReadMessage ok ", "", "msgType", msgType, "userIP", conn.RemoteAddr().String(), "userUid", sendIDAndPlatformID)
}
```

å°†è¯»å–åˆ°çš„æ¶ˆæ¯è§£æä¸º `Req` ç»“æ„ï¼š

```
m := Req{}
json.Unmarshal(msg, &m)
```

æ­¤å¤„å‡è®¾æ¶ˆæ¯æ˜¯JSONæ ¼å¼çš„ï¼Œå¹¶å°è¯•å°†å…¶ååºåˆ—åŒ–åˆ° `Req` ç±»å‹çš„å˜é‡ä¸­ã€‚

ç„¶åï¼Œè§£æè¯¥æ¶ˆæ¯ï¼š

```
ws.msgParse(conn, msg)
```

åŒæ ·ï¼Œæœ‰ä¸€äº›è¢«æ³¨é‡Šæ‰çš„ä»£ç ï¼Œå¯èƒ½ç”¨äºè°ƒè¯•ï¼š

```
//log.Info("debug memory msgParse begin ", m)
//time.Sleep(1 * time.Second)
//...
//log.Info("debug memory msgParse end ", m)
//time.Sleep(1 * time.Second)
```

æ•´ä¸ªå¾ªç¯ç»“æŸåï¼Œå®ƒå°†å›åˆ°å¼€å§‹ï¼Œç»§ç»­è¯»å–ä¸‹ä¸€ä¸ªæ¶ˆæ¯ã€‚

```go
func (ws *WServer) msgParse(conn *UserConn, jsonMsg []byte) {
	m := Req{}
	if err := json.Unmarshal(jsonMsg, &m); err != nil {
		SendOneConnMessage(EventData{"error", 100, "Unmarshal failed", "", ""}, conn)
		return
	}

	defer func() {
		if r := recover(); r != nil {
			SendOneConnMessage(EventData{m.ReqFuncName, StatusBadParameter, StatusText(StatusBadParameter), "", m.OperationID}, conn)
			log.Info("", "msgParse", "bad request, panic is ", r)
			buf := make([]byte, 1<<16)
			runtime.Stack(buf, true)
			log.Info("", "msgParse", "call", string(buf))
		}
	}()

	log.Info("", "msgParse", "recv request from web: ", "reqFuncName ", m.ReqFuncName, "data ", m.Data, "recv jsonMsg: ", string(jsonMsg))

	if m.ReqFuncName == "Login" {
		//	rwLock.Lock()
		ws.DoLogin(m, conn)
		log.Info(m.OperationID, "msgParse", m)
		//	rwLock.Unlock()
		return
	}

	UserRouteRwLock.RLock()
	defer UserRouteRwLock.RUnlock()
	//	rwLock.RLock()
	//	defer rwLock.RUnlock()
	urm, ok := UserRouteMap[m.UserID]

	if !ok {
		log.Info("", "msgParse", "user not login failed, must login first: ", m.UserID)
		SendOneConnMessage(EventData{"Login", StatusNoLogin, StatusText(StatusNoLogin), "", m.OperationID}, conn)
		return
	}
	parms := []reflect.Value{reflect.ValueOf(m.Data), reflect.ValueOf(m.OperationID)}
	vf, ok := (urm.refName)[m.ReqFuncName]
	if ok {
		vf.Call(parms)
	} else {
		log.Info("", "msgParse", "no func ", m.ReqFuncName)
		SendOneConnMessage(EventData{m.ReqFuncName, StatusBadParameter, StatusText(StatusBadParameter), "", m.OperationID}, conn)
	}

}
```

è¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ªæ–¹æ³• `msgParse`ï¼Œå®ƒçš„ä¸»è¦ä»»åŠ¡æ˜¯å¯¹ä¼ å…¥çš„JSONæ¶ˆæ¯è¿›è¡Œè§£æï¼Œå¹¶æ ¹æ®è§£æå‡ºçš„è¯·æ±‚å‡½æ•°åç§° (`ReqFuncName`) æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚è®©æˆ‘ä»¬å†è¿›è¡Œé€è¡Œè§£æã€‚

```go
func (ws *WServer) msgParse(conn *UserConn, jsonMsg []byte) {
```

è¿™æ˜¯ `*WServer` çš„æ–¹æ³•ï¼Œåä¸º `msgParse`ã€‚å®ƒæ¥æ”¶ä¸€ä¸ª `UserConn` ç±»å‹çš„ `conn` å’Œä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ `jsonMsg`ï¼ˆåŒ…å«JSONæ¶ˆæ¯å†…å®¹ï¼‰ã€‚

```
m := Req{}
if err := json.Unmarshal(jsonMsg, &m); err != nil {
```

å°è¯•å°† `jsonMsg` ååºåˆ—åŒ–ä¸º `Req` ç±»å‹çš„å˜é‡ `m`ã€‚å¦‚æœå‡ºé”™ï¼Œå‘è¿æ¥å‘é€ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ï¼Œå¹¶é€€å‡ºå‡½æ•°ã€‚

```go
SendOneConnMessage(EventData{"error", 100, "Unmarshal failed", "", ""}, conn)
return
```

æ¥ä¸‹æ¥ï¼Œæœ‰ä¸€ä¸ªå»¶è¿Ÿæ‰§è¡Œçš„å‡½æ•°æ¥æ•è·å¯èƒ½çš„ panicï¼š

```
defer func() {
	if r := recover(); r != nil {
		...
	}
}()
```

è¿™æ˜¯ä¸€ä¸ªå¸¸è§çš„Goé”™è¯¯å¤„ç†æ¨¡å¼ï¼Œç”¨äºæ•è·å‡½æ•°ä¸­çš„ä»»ä½•panicï¼Œå¹¶å¯¹å…¶è¿›è¡Œå¤„ç†ã€‚

```go
log.Info("", "msgParse", "recv request from web: ", "reqFuncName ", m.ReqFuncName, "data ", m.Data, "recv jsonMsg: ", string(jsonMsg))
```

è®°å½•ä»Webæ¥æ”¶åˆ°çš„è¯·æ±‚æ—¥å¿—ã€‚

```go
if m.ReqFuncName == "Login" {
	ws.DoLogin(m, conn)
	log.Info(m.OperationID, "msgParse", m)
	return
}
```

å¦‚æœè¯·æ±‚çš„å‡½æ•°åç§°æ˜¯â€œLoginâ€ï¼Œåˆ™è°ƒç”¨ `DoLogin` æ–¹æ³•ï¼Œå¹¶è®°å½•æ—¥å¿—ã€‚

æ¥ä¸‹æ¥ï¼Œé”å®š `UserRouteRwLock`ï¼š

```go
UserRouteRwLock.RLock()
defer UserRouteRwLock.RUnlock()
```

è¿™æ˜¯ä¸€ä¸ªè¯»å†™é”ï¼Œç”¨äºä¿æŠ¤å¯èƒ½ç”±å¤šä¸ªgoroutineå¹¶å‘è®¿é—®çš„æ•°æ®ã€‚

```
urm, ok := UserRouteMap[m.UserID]
```

å°è¯•ä» `UserRouteMap` ä¸­è·å–ç”¨æˆ·çš„è·¯ç”±ä¿¡æ¯ã€‚

```go
if !ok {
	...
	SendOneConnMessage(EventData{"Login", StatusNoLogin, StatusText(StatusNoLogin), "", m.OperationID}, conn)
	return
}
```

å¦‚æœç”¨æˆ·ä¸åœ¨`UserRouteMap`ä¸­ï¼Œå‘é€ä¸€ä¸ªéœ€è¦ç™»å½•çš„æ¶ˆæ¯ã€‚

```go
parms := []reflect.Value{reflect.ValueOf(m.Data), reflect.ValueOf(m.OperationID)}
vf, ok := (urm.refName)[m.ReqFuncName]
```

è¿™é‡Œä½¿ç”¨äº†Goçš„ `reflect` åŒ…ã€‚æ ¹æ®è¯·æ±‚çš„å‡½æ•°åç§°ä»ç”¨æˆ·çš„è·¯ç”±ä¿¡æ¯ä¸­æŸ¥æ‰¾å‡½æ•°ã€‚

```go
if ok {
	vf.Call(parms)
} else {
	...
	SendOneConnMessage(EventData{m.ReqFuncName, StatusBadParameter, StatusText(StatusBadParameter), "", m.OperationID}, conn)
}
```

å¦‚æœå‡½æ•°å­˜åœ¨ï¼Œåˆ™è°ƒç”¨å®ƒã€‚å¦åˆ™ï¼Œå‘é€ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ã€‚

æ€»ä½“æ¥è¯´ï¼Œè¿™ä¸ª `msgParse` æ–¹æ³•æ˜¯ä¸€ä¸ªä¸­å¿ƒå¤„ç†ç‚¹ï¼Œå®ƒåŸºäºä¼ å…¥çš„JSONæ¶ˆæ¯å†…å®¹å†³å®šåº”æ‰§è¡Œå“ªäº›æ“ä½œã€‚è¿™ä¸ªæ¨¡å¼å…è®¸æ‚¨åœ¨ä¸æ›´æ”¹æœåŠ¡å™¨ä»£ç çš„æƒ…å†µä¸‹ï¼Œé€šè¿‡å‘å®¢æˆ·ç«¯å‘é€ä¸åŒçš„JSONè¯·æ±‚æ¥æ‰©å±•æˆ–æ›´æ”¹è¡Œä¸ºã€‚

**ç»§ç»­è§£æ Dologin ä»£ç **

```go
func (ws *WServer) DoLogin(m Req, conn *UserConn) {
	UserRouteRwLock.RLock()
	defer UserRouteRwLock.RUnlock()
	urm, ok := UserRouteMap[m.UserID]
	if !ok {
		log.Info(m.OperationID, "login", "user first login: ", m)
		refR := GenUserRouterNoLock(m.UserID, m.Batch, m.OperationID)
		params := []reflect.Value{reflect.ValueOf(m.Data), reflect.ValueOf(m.OperationID)}
		vf, ok := refR.refName[m.ReqFuncName]
		if ok {
			vf.Call(params)
		} else {
			log.Info("", "login", "no func name: ", m.ReqFuncName, m)
			SendOneConnMessage(EventData{m.ReqFuncName, StatusBadParameter, StatusText(StatusBadParameter), "", m.OperationID}, conn)
		}

	} else {
		if urm.wsRouter.getMyLoginStatus() == constant.LoginSuccess {
			//send ok
			SendOneConnMessage(EventData{"Login", 0, "ok", "", m.OperationID}, conn)
		} else {
			log.Info("", "login", "login status pending, try after 5 second ", urm.wsRouter.getMyLoginStatus(), m.UserID)
			SendOneConnMessage(EventData{"Login", StatusLoginPending, StatusText(StatusLoginPending), "", m.OperationID}, conn)
		}
	}
}
```

1. å®šä¹‰ `DoLogin` æ–¹æ³•ï¼š

```
func (ws *WServer) DoLogin(m Req, conn *UserConn) {
```

æ­¤æ–¹æ³•æ¥å—ä¸¤ä¸ªå‚æ•°ï¼šä¸€ä¸ª `Req` ç±»å‹çš„ `m`ï¼ˆè¡¨ç¤ºè¯·æ±‚ï¼‰å’Œä¸€ä¸ª `UserConn` ç±»å‹çš„ `conn`ï¼ˆè¡¨ç¤ºç”¨æˆ·è¿æ¥ï¼‰ã€‚

1. é”å®š `UserRouteRwLock`ï¼ˆè¯»é”ï¼‰ï¼š

```
UserRouteRwLock.RLock()
defer UserRouteRwLock.RUnlock()
```

è¿™æ˜¯ä¸€ä¸ªè¯»å†™é”ï¼Œç”¨äºä¿æŠ¤å¯èƒ½ç”±å¤šä¸ª goroutine å¹¶å‘è®¿é—®çš„ `UserRouteMap` æ•°æ®ã€‚

1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²åœ¨ `UserRouteMap` ä¸­ï¼š

```
urm, ok := UserRouteMap[m.UserID]
```

å°è¯•ä» `UserRouteMap` ä¸­è·å–ç”¨æˆ·çš„è·¯ç”±ä¿¡æ¯ã€‚

1. å¦‚æœç”¨æˆ·ä¸åœ¨ `UserRouteMap` ä¸­ï¼Œå³ä»–ä»¬æ˜¯é¦–æ¬¡ç™»å½•ï¼š

```
if !ok {
	log.Info(m.OperationID, "login", "user first login: ", m)
```

è®°å½•ç”¨æˆ·é¦–æ¬¡ç™»å½•çš„æ—¥å¿—ã€‚

1. ä½¿ç”¨ `GenUserRouterNoLock` å‡½æ•°ç”Ÿæˆç”¨æˆ·çš„è·¯ç”±ä¿¡æ¯ï¼š

```
refR := GenUserRouterNoLock(m.UserID, m.Batch, m.OperationID)
```

1. ä½¿ç”¨ `reflect` åŒ…æ¥è°ƒç”¨ç›¸åº”çš„å‡½æ•°ï¼š

```
params := []reflect.Value{reflect.ValueOf(m.Data), reflect.ValueOf(m.OperationID)}
vf, ok := refR.refName[m.ReqFuncName]
```

åŸºäºè¯·æ±‚ä¸­çš„å‡½æ•°åç§°ï¼Œä»ç”¨æˆ·çš„è·¯ç”±ä¿¡æ¯ä¸­æŸ¥æ‰¾å‡½æ•°ã€‚

1. å¦‚æœå‡½æ•°å­˜åœ¨ï¼Œè°ƒç”¨å®ƒï¼š

```
if ok {
	vf.Call(params)
}
```

1. å¦‚æœå‡½æ•°ä¸å­˜åœ¨ï¼Œå‘é€ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ï¼š

```
else {
	log.Info("", "login", "no func name: ", m.ReqFuncName, m)
	SendOneConnMessage(EventData{m.ReqFuncName, StatusBadParameter, StatusText(StatusBadParameter), "", m.OperationID}, conn)
}
```

1. å¦‚æœç”¨æˆ·å·²ç»åœ¨ `UserRouteMap` ä¸­ï¼Œå³ä»–ä»¬ä¹‹å‰å·²ç»ç™»å½•è¿‡ï¼š

```

} else {
```

1. æ£€æŸ¥ç”¨æˆ·çš„ç™»å½•çŠ¶æ€ã€‚å¦‚æœç™»å½•æˆåŠŸï¼Œåˆ™å‘é€ä¸€ä¸ªæˆåŠŸçš„æ¶ˆæ¯ï¼š

```
if urm.wsRouter.getMyLoginStatus() == constant.LoginSuccess {
	SendOneConnMessage(EventData{"Login", 0, "ok", "", m.OperationID}, conn)
}
```

1. å¦‚æœç™»å½•çŠ¶æ€æ˜¯å¾…å®šçš„ï¼Œå‘é€ä¸€ä¸ªæ¶ˆæ¯å‘ŠçŸ¥ç”¨æˆ·ç¨åé‡è¯•ï¼š

```
else {
	log.Info("", "login", "login status pending, try after 5 second ", urm.wsRouter.getMyLoginStatus(), m.UserID)
	SendOneConnMessage(EventData{"Login", StatusLoginPending, StatusText(StatusLoginPending), "", m.OperationID}, conn)
}
```

æ€»ç»“ï¼šè¿™ä¸ª `DoLogin` æ–¹æ³•å¤„ç†ç™»å½•è¯·æ±‚ï¼Œæ ¹æ®ç”¨æˆ·æ˜¯å¦å·²ç»ç™»å½•ä»¥åŠä»–ä»¬çš„ç™»å½•çŠ¶æ€æ¥æ‰§è¡Œä¸åŒçš„æ“ä½œã€‚å¦‚æœç”¨æˆ·æ˜¯é¦–æ¬¡ç™»å½•ï¼Œä¼šä¸ºå…¶ç”Ÿæˆè·¯ç”±ä¿¡æ¯å¹¶å°è¯•è°ƒç”¨ç›¸å…³çš„å‡½æ•°ã€‚å¦‚æœç”¨æˆ·å·²ç»ç™»å½•ï¼Œä¼šæ ¹æ®å…¶ç™»å½•çŠ¶æ€è¿”å›ç›¸åº”çš„æ¶ˆæ¯ã€‚



**GenUserRouterNoLock:**

```go
func GenUserRouterNoLock(uid string, batchMsg int, operationID string) *RefRouter {
	_, ok := UserRouteMap[uid]
	if ok {
		return nil
	}
	RouteMap1 := make(map[string]reflect.Value, 0)
	var wsRouter1 WsFuncRouter
	wsRouter1.uId = uid

	vf := reflect.ValueOf(&wsRouter1)
	vft := vf.Type()

	mNum := vf.NumMethod()
	for i := 0; i < mNum; i++ {
		mName := vft.Method(i).Name
		log.Info(operationID, "index:", i, " MethodName:", mName)
		RouteMap1[mName] = vf.Method(i)
	}
	wsRouter1.InitSDK(ConfigSvr, operationID)
	log.Info(operationID, "SetAdvancedMsgListener() ", uid)
	wsRouter1.SetAdvancedMsgListener()
	if batchMsg == 1 {
		log.Info(operationID, "SetBatchMsgListener() ", uid)
		wsRouter1.SetBatchMsgListener()
	}
	wsRouter1.SetConversationListener()
	log.Info(operationID, "SetFriendListener() ", uid)
	wsRouter1.SetFriendListener()
	log.Info(operationID, "SetGroupListener() ", uid)
	wsRouter1.SetGroupListener()
	log.Info(operationID, "SetUserListener() ", uid)
	wsRouter1.SetUserListener()
	log.Info(operationID, "SetSignalingListener() ", uid)
	wsRouter1.SetSignalingListener()
	log.Info(operationID, "setWorkMomentsListener()", uid)
	wsRouter1.SetWorkMomentsListener()
	log.Info(operationID, "SetOrganizationListener()", uid)
	wsRouter1.SetOrganizationListener()
	var rr RefRouter
	rr.refName = RouteMap1
	rr.wsRouter = &wsRouter1
	UserRouteMap[uid] = rr
	log.Info(operationID, "insert UserRouteMap: ", uid)
	return &rr
}
```


è¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ªåä¸º `GenUserRouterNoLock` çš„å‡½æ•°ï¼Œå®ƒçš„ä»»åŠ¡æ˜¯ä¸ºç‰¹å®šçš„ç”¨æˆ·ç”Ÿæˆè·¯ç”±ä¿¡æ¯ã€‚å…·ä½“æ¥è¯´ï¼Œå®ƒä¸ºç”¨æˆ·çš„WebSocketåŠŸèƒ½ç”Ÿæˆäº†ä¸€ä¸ªè·¯ç”±æ˜ å°„ã€‚è¿™é‡Œæ˜¯è¯¦ç»†çš„æ­¥éª¤å’Œä»£ç åˆ†æï¼š

1. å®šä¹‰ `GenUserRouterNoLock` å‡½æ•°ï¼š

```
func GenUserRouterNoLock(uid string, batchMsg int, operationID string) *RefRouter {
```

æ­¤å‡½æ•°æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼š`uid`ï¼ˆç”¨æˆ·IDï¼‰ã€`batchMsg`ï¼ˆæ‰¹å¤„ç†æ¶ˆæ¯æ ‡è¯†ç¬¦ï¼‰å’Œ`operationID`ï¼ˆæ“ä½œIDï¼‰ã€‚

1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç»å­˜åœ¨äº `UserRouteMap` ä¸­ï¼š

```go
_, ok := UserRouteMap[uid]
if ok {
	return nil
}
```

å¦‚æœç”¨æˆ·å·²ç»å­˜åœ¨ï¼Œåˆ™è¿”å› `nil`ã€‚

1. åˆå§‹åŒ–æœ¬åœ°è·¯ç”±æ˜ å°„å’ŒWebSocketå‡½æ•°è·¯ç”±å™¨å®ä¾‹ï¼š

```go
RouteMap1 := make(map[string]reflect.Value, 0)
var wsRouter1 WsFuncRouter
wsRouter1.uId = uid
```

1. ä½¿ç”¨ `reflect` åŒ…è·å– `wsRouter1` çš„æ‰€æœ‰æ–¹æ³•ï¼Œå¹¶å°†å…¶åç§°å’Œæ–¹æ³•å€¼æ·»åŠ åˆ° `RouteMap1` ä¸­ï¼š

```go
vf := reflect.ValueOf(&wsRouter1)
vft := vf.Type()

mNum := vf.NumMethod()
for i := 0; i < mNum; i++ {
	mName := vft.Method(i).Name
	log.Info(operationID, "index:", i, " MethodName:", mName)
	RouteMap1[mName] = vf.Method(i)
}
```

1. åˆå§‹åŒ–SDKå¹¶è®¾ç½®ä¸åŒçš„ç›‘å¬å™¨ã€‚è¿™äº›ç›‘å¬å™¨å¯èƒ½ç”¨äºå¤„ç†å„ç§WebSocketæ¶ˆæ¯æˆ–äº‹ä»¶ï¼š

```go
wsRouter1.InitSDK(ConfigSvr, operationID)
...
wsRouter1.SetAdvancedMsgListener()
...
wsRouter1.SetBatchMsgListener()
...
```

1. ä¸ºç”¨æˆ·åˆ›å»ºä¸€ä¸ªæ–°çš„ `RefRouter` å®ä¾‹ï¼Œå…¶ä¸­åŒ…å«äº†è·¯ç”±æ˜ å°„å’ŒWebSocketè·¯ç”±å™¨çš„å¼•ç”¨ï¼š

```go
var rr RefRouter
rr.refName = RouteMap1
rr.wsRouter = &wsRouter1
```

1. å°†æ–°çš„ `RefRouter` å®ä¾‹æ·»åŠ åˆ° `UserRouteMap` ä¸­ï¼Œä»¥ç”¨æˆ·IDä¸ºé”®ï¼š

```go
UserRouteMap[uid] = rr
log.Info(operationID, "insert UserRouteMap: ", uid)
```

1. æœ€åï¼Œè¿”å›æ–°åˆ›å»ºçš„ `RefRouter` å®ä¾‹çš„å¼•ç”¨ï¼š

```go
return &rr
```

æ€»ä½“è¯´ï¼Œæ­¤å‡½æ•°çš„ç›®çš„æ˜¯ä¸ºç”¨æˆ·ç”Ÿæˆä¸€ä¸ªWebSocketå‡½æ•°çš„è·¯ç”±ä¿¡æ¯ã€‚å¦‚æœç”¨æˆ·å·²ç»æœ‰è·¯ç”±ä¿¡æ¯ï¼Œå‡½æ•°å°†è¿”å›nilã€‚å¦åˆ™ï¼Œå®ƒå°†ä¸ºç”¨æˆ·çš„æ¯ä¸ªWebSocketåŠŸèƒ½æ–¹æ³•åˆ›å»ºä¸€ä¸ªè·¯ç”±æ˜ å°„ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°å…¨å±€çš„`UserRouteMap`ä¸­ã€‚



## END é“¾æ¥

<ul><li><div><a href = '70.md' style='float:left'>â¬†ï¸ä¸Šä¸€èŠ‚ğŸ”—  </a><a href = '72.md' style='float: right'>  ï¸ä¸‹ä¸€èŠ‚ğŸ”—</a></div></li></ul>

+ [â“‚ï¸å›åˆ°ç›®å½•ğŸ ](../README.md)

+ [**ğŸ«µå‚ä¸è´¡çŒ®ğŸ’â¤ï¸â€ğŸ”¥ğŸ’–**](https://nsddd.top/archives/contributors))

+ âœ´ï¸ç‰ˆæƒå£°æ˜ &copy; ï¼šæœ¬ä¹¦æ‰€æœ‰å†…å®¹éµå¾ª[CC-BY-SA 3.0åè®®ï¼ˆç½²å-ç›¸åŒæ–¹å¼å…±äº«ï¼‰&copy;](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0åè®®æ–‡æœ¬) 
